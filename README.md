# React Workshop for GETS AS

## Before we begin

Before starting the workshop you should make sure you have the required dependencies installed

  - NPM
  - Node.js
  - Code editor of your choice (VSCode is great)

If you're running Visual Studio Code 1.33.0 or 1.33.1 there is a performance bug with Intellisense.
To temporarily fix this we can disable the built-in extension "TypeScript and JavaScript Language Features".
Go to Extensions, and search for '@builtin typescript' to find it.

Once you have installed all required dependencies we can set-up our project with:

`npx create-react-app mcu-avengers-equipment`

We do this for convenience for the workshop - create-react-app will run a script that sets up a simple Hello World-type
application.

Navigate to the root folder of the project, and run the following commands to install our remaining dependencies:

`npx -p @storybook/cli sb init --type react` - This will install storybook in the project allowing us to test individual UI-components
`npm install --save styled-components@latest react@latest react-dom@latest` - This will install styled-components which we will use for our CSS
and also update to the latest version of react and react-dom.
`npm install --save-dev prop-types@latest` - We will be using prop-types to strong type our components
`npm run build` - To make our initial build of the solution
`npm install` - To make sure all of our dependencies from our package.json is installed

### Delete autogenerated code we dont need

In the `src` folder, delete `App.css`, `Index.css` and `logo.svg`.
In `App.js` and `Index.js` remove all references to the files we just deleted.
In `App.js` remove all code that isn't prefixed by either an `import` or `export` statement.

### Configuring the storybook

Navigate to `storybook/config.js` from the root folder of the project.

```
import { configure } from '@storybook/react';

const loadstories = () => {
  const req = require.context('../stories', true, /\.stories\.js$/);
  req.keys().forEach(filename => req(filename));
}

configure(loadStories, module);
```

This configuration setting will make the storybook load in any files with the suffix `[somefile].stories.js` from anywhere in our project as a story module.

### Adding some mockdata

Create a new file `/src/mockdata.js` containing the following code.
This will populate an array with 100 random products that we will be using in our app.

```
const generateNumber = length => {
  const seed = Math.random();
  const max = Math.pow(10, length);
  return Math.floor(seed * max).toString().padStart(length, 0);
};

const colors = ['white', 'blue', 'red', 'green', 'blue', 'rainbow', 'cyan', 'pink', 'chair', 'angry'].map(e => `${generateNumber(1).padStart(3, 0)} ${e}`);

const product = ['Vikafjell', 'Sway', 'Sweet', 'Nike', 'NorrÃ¸na', 'Devold', 'Ecco', 'Hydra', 'Thanos', 'Jon Snow'];

const supplier = [
  'Element Productions AS',
  'Devold of Norway AS',
  'Missing Link Group',
  'Suno Sport Norge',
  'Nick Fury AS',
  'Steve Rogers Inc',
  'Tony Stark CC',
  'Affiliated Avengers',
  'Beep-Boop-Beep',
  'Bran 2000 Raven Simulator',
];

const createNewJson = () => {
  return {
    "ArticleID": generateNumber(5),
    "ArticleNo": `${generateNumber(5)}-EL${generateNumber(5)}`,
    "Name": "Varm ullgenser",
    "SupplierName": supplier[Math.floor(Math.random() * 10)],
    "ProductLineName": product[Math.floor(Math.random() * 10)],
    "MainGroupName": "Tekstil",
    "ArticleGroup2Name": "MellomLag",
    "ArticleGroup3Name": "Ullgenser",
    "PurchasePrice": generateNumber(3),
    "SalesPrice": generateNumber(3),
    "SuggestedPrice": generateNumber(4),
    "Variants": [
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "S"
        },
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "M"
        },
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "L"
        }
    ],
  }
};

export default Array(100).fill({}).map(each => createNewJson()); 
```

## Lets get started coding!

Lets start coding!  The goal for this workshop is to create a table that displays our mockdata, we will also use the object keys for table headings.
Then we will make a button to delete products from the table, a feature to sort each column alphabetically and an input field that we can use to filter data base on our typed input.

### Starting small

Our first task is to create a simple table row from a data input of variable length.  For this task we need to use two of our installed NPM-modules: `React` and `styled-components`.
Go ahead and create a file `{root}/components/Row.jsx` - the components folder is a part of our design pattern, it is where we will store generic Components that we will likely reuse alot throughout our application. 
In the ES6 syntax that React uses - we can use the new, improved import statements.

```
import React from 'react';
import styled from 'styled-components';
```

Notice how React uses an uppercase syntax for Components, and lowercase for functions and variables.
When using styled-components it is important to remember that while the function `styled()` generates a className,
we have to manually pass this down to the DOM-node unless we are creating a pure styled component such as `styled.tr`,
as opposed to a `styled(Row)` - the className will be available as a prop on the component that is styled.

Lets also make the reasonable assumption that we recieve a 'values' array as a prop, and map these values to each individual
table cell.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types;

const Row = ({ className, values }) => (
  <tr className={className}>
    {values.map((value, index) => <td key={index}>{value}</td>)}
  </tr>
);

Row.propTypes = {
  className: PropTypes.string.isRequired;
  values: PropTypes.array.isRequired;
};

export default styled(Row)`
  width: 100%;
`;
```

Once we have created our `Row` component, we should try it out in our storybook to make sure it renders as intended. (Keep in mind that a tr-element is intended to render in the context of a `<table>` or a `<tbody>`).

Head over to `{root}/stories/index.stories.js`.
Feel free to rip out most of the existing code, the only imports we need are `React`, `storiesOf` and `Row` from `../src/components/Row`.

We also need a simple array to populate our component with, such as: `const values = ['1', '2', '3']`.

And then we need to create a stories module.

`storiesOf('MCU Avengers!', module).add('Table Row', () => <Row values={values}/>)`

If we now run the command `npm run storybook` in our terminal, we can see that we have created our first story - and all our values are displayed in a row.  Though ... not in a very nice way since we are outside of the context of a Table.

## Now lets try again

So we need to create out `Table` component.
Just like the `Row`, we will make our `Table.jsx` in `{root}/components`.
Notice that we always name our `.jsx`-files the same as the component.  This is considered good practice in React.

Our table will again make use of `React`, `styled` and `PropTypes` - but we will also use our `Row` component here.

We also want to accept more props in the table - we will require an array of `headings` for all our columns, and an array of `rows` containing all the data we will populate our table with.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import Row from './Row';

const Table = ({ className, headings, rows }) => (
  <table className={className}>
    <thead><tr>{headings.map((heading, index) => <th key={index}>{heading}</th>)}<th /></tr></thead>
    <tbody>
      {rows.map((row, index) => <Row key={index} values={row}/>)}
    </tbody>
  </table>
);

Table.propTypes = {
  className: PropTypes.string.isRequired,
  keys: PropTypes.array.isRequired,
  rows: PropTypes.array.isRequired,
}

export default styled(Table)`
  width: 100%;
  border-spacing: 0;
`;
```

We may then update our storybook to show the `Table` we just made.

```
import React from 'react';
import { storiesOf } from '@storybook/react';
import Row from '../src/components/Row';
import Table from '../src/components/Table';

const keys = ['a', 'b', 'c'];
const values = ['1', '2', '3'];
const rows = Array(8).fill(values);

storiesOf('MCU Avengers!', module)
  .add('Table Row', () => <Row values={values}/>)
  .add('Table', () => <Table keys={keys} rows={rows}/>);
```

## Making the App

Now lets connect our mockdata to the table and see if we can run the app - go to the `App.js`-file at `{root}`.  You might remember we removed everything from here earlier?

import `React`, `styled`, `PropTypes`, `Table` and `mock from './mockdata'`.

Since we don't need all the data from the mock for this table, we haven't created any functions to handle nested arrays yet - we will ommit the product variants, for the convenience of this workshop.

We can do this in the scope of our component, but this means we need a return statement to handle our jsx.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import mock from './mockdata';
import Table from './components/Table';

const App = ({ className }) => {
  const { Variants, ...rest } = mock[0];
  const keys = Object.keys(rest);
  const rows = mock.map(row => {
    const { Variants, ...rest } = row;
    return Object.values(rest);
  });
  const headings = keys.map(key => <h2>{key}</h2>);
  return (
    <div className={className}>
      <Table headings={headings} rows={rows}>
    </div>
  );
};

App.propTypes = {
  className: PropTypes.string.isRequired,
};

export default styled(App)`
  display: flex;
  flex-direction: column;
  justify-content: center;
  text-align: center;
`;
```

