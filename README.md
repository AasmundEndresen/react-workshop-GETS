# React Workshop for GETS AS

## Before we begin

Before starting the workshop you should make sure you have the required dependencies installed

  - NPM
  - Node.js
  - Code editor of your choice (VSCode is great)

If you're running Visual Studio Code 1.33.0 or 1.33.1 there is a performance bug with Intellisense.
To temporarily fix this we can disable the built-in extension "TypeScript and JavaScript Language Features".
Go to Extensions, and search for '@builtin typescript' to find it.

Once you have installed all required dependencies we can set-up our project with:

`npx create-react-app mcu-avengers-equipment`

We do this for convenience for the workshop - create-react-app will run a script that sets up a simple Hello World-type
application.

Navigate to the root folder of the project, and run the following commands to install our remaining dependencies:

`npx -p @storybook/cli sb init --type react` - This will install storybook in the project allowing us to test individual UI-components
`npm install --save styled-components@latest react@latest react-dom@latest` - This will install styled-components which we will use for our CSS
and also update to the latest version of react and react-dom.
`npm install --save-dev prop-types@latest` - We will be using prop-types to strong type our components
`npm run build` - To make our initial build of the solution
`npm install` - To make sure all of our dependencies from our package.json is installed

### Delete autogenerated code we dont need

In the `src` folder, delete `App.css`, `Index.css` and `logo.svg`.
In `App.js` and `Index.js` remove all references to the files we just deleted.
In `App.js` remove all code that isn't prefixed by either an `import` or `export` statement.

### Configuring the storybook

Navigate to `storybook/config.js` from the root folder of the project.

```
import { configure } from '@storybook/react';

const loadstories = () => {
  const req = require.context('../stories', true, /\.stories\.js$/);
  req.keys().forEach(filename => req(filename));
}

configure(loadStories, module);
```

This configuration setting will make the storybook load in any files with the suffix `[somefile].stories.js` from anywhere in our project as a story module.

### Adding some mockdata

Create a new file `/src/mockdata.js` containing the following code.
This will populate an array with 100 random products that we will be using in our app.

```
const generateNumber = length => {
  const seed = Math.random();
  const max = Math.pow(10, length);
  return Math.floor(seed * max).toString().padStart(length, 0);
};

const colors = ['white', 'blue', 'red', 'green', 'blue', 'rainbow', 'cyan', 'pink', 'chair', 'angry'].map(e => `${generateNumber(1).padStart(3, 0)} ${e}`);

const product = ['Vikafjell', 'Sway', 'Sweet', 'Nike', 'NorrÃ¸na', 'Devold', 'Ecco', 'Hydra', 'Thanos', 'Jon Snow'];

const supplier = [
  'Element Productions AS',
  'Devold of Norway AS',
  'Missing Link Group',
  'Suno Sport Norge',
  'Nick Fury AS',
  'Steve Rogers Inc',
  'Tony Stark CC',
  'Affiliated Avengers',
  'Beep-Boop-Beep',
  'Bran 2000 Raven Simulator',
];

const createNewJson = () => {
  return {
    "ArticleID": generateNumber(5),
    "ArticleNo": `${generateNumber(5)}-EL${generateNumber(5)}`,
    "Name": "Varm ullgenser",
    "SupplierName": supplier[Math.floor(Math.random() * 10)],
    "ProductLineName": product[Math.floor(Math.random() * 10)],
    "MainGroupName": "Tekstil",
    "ArticleGroup2Name": "MellomLag",
    "ArticleGroup3Name": "Ullgenser",
    "PurchasePrice": generateNumber(3),
    "SalesPrice": generateNumber(3),
    "SuggestedPrice": generateNumber(4),
    "Variants": [
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "S"
        },
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "M"
        },
        {
            "EAN": generateNumber(13),
            "Color": `${colors[Math.floor(Math.random() * 10)]}`,
            "Size": "L"
        }
    ],
  }
};

export default Array(100).fill({}).map(each => createNewJson()); 
```

## Lets get started coding!

Lets start coding!  The goal for this workshop is to create a table that displays our mockdata, we will also use the object keys for table headings.
Then we will make a button to delete products from the table, a feature to sort each column alphabetically and an input field that we can use to filter data base on our typed input.

### Starting small

Our first task is to create a simple table row from a data input of variable length.  For this task we need to use two of our installed NPM-modules: `React` and `styled-components`.
Go ahead and create a file `{root}/components/Row.jsx` - the components folder is a part of our design pattern, it is where we will store generic Components that we will likely reuse alot throughout our application. 
In the ES6 syntax that React uses - we can use the new, improved import statements.

```
import React from 'react';
import styled from 'styled-components';
```

Notice how React uses an uppercase syntax for Components, and lowercase for functions and variables.
When using styled-components it is important to remember that while the function `styled()` generates a className,
we have to manually pass this down to the DOM-node unless we are creating a pure styled component such as `styled.tr`,
as opposed to a `styled(Row)` - the className will be available as a prop on the component that is styled.

Lets also make the reasonable assumption that we recieve a 'values' array as a prop, and map these values to each individual
table cell.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types;

const Row = ({ className, values }) => (
  <tr className={className}>
    {values.map((value, index) => <td key={index}>{value}</td>)}
  </tr>
);

Row.propTypes = {
  className: PropTypes.string.isRequired;
  values: PropTypes.array.isRequired;
};

export default styled(Row)`
  width: 100%;
`;
```

Once we have created our `Row` component, we should try it out in our storybook to make sure it renders as intended. (Keep in mind that a tr-element is intended to render in the context of a `<table>` or a `<tbody>`).

Head over to `{root}/stories/index.stories.js`.
Feel free to rip out most of the existing code, the only imports we need are `React`, `storiesOf` and `Row` from `../src/components/Row`.

We also need a simple array to populate our component with, such as: `const values = ['1', '2', '3']`.

And then we need to create a stories module.

`storiesOf('MCU Avengers!', module).add('Table Row', () => <Row values={values}/>)`

If we now run the command `npm run storybook` in our terminal, we can see that we have created our first story - and all our values are displayed in a row.  Though ... not in a very nice way since we are outside of the context of a Table.

### Now lets try again

So we need to create out `Table` component.
Just like the `Row`, we will make our `Table.jsx` in `{root}/components`.
Notice that we always name our `.jsx`-files the same as the component.  This is considered good practice in React.

Our table will again make use of `React`, `styled` and `PropTypes` - but we will also use our `Row` component here.

We also want to accept more props in the table - we will require an array of `headings` for all our columns, and an array of `rows` containing all the data we will populate our table with.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import Row from './Row';

const Table = ({ className, headings, rows }) => (
  <table className={className}>
    <thead><tr>{headings.map((heading, index) => <th key={index}>{heading}</th>)}<th /></tr></thead>
    <tbody>
      {rows.map((row, index) => <Row key={index} values={row}/>)}
    </tbody>
  </table>
);

Table.propTypes = {
  className: PropTypes.string.isRequired,
  keys: PropTypes.array.isRequired,
  rows: PropTypes.array.isRequired,
}

export default styled(Table)`
  width: 100%;
  border-spacing: 0;
`;
```

We may then update our storybook to show the `Table` we just made.

```
import React from 'react';
import { storiesOf } from '@storybook/react';
import Row from '../src/components/Row';
import Table from '../src/components/Table';

const keys = ['a', 'b', 'c'];
const values = ['1', '2', '3'];
const rows = Array(8).fill(values);

storiesOf('MCU Avengers!', module)
  .add('Table Row', () => <Row values={values}/>)
  .add('Table', () => <Table keys={keys} rows={rows}/>);
```

### Making the App

Now lets connect our mockdata to the table and see if we can run the app - go to the `App.js`-file at `{root}`.  You might remember we removed everything from here earlier?

import `React`, `styled`, `PropTypes`, `Table` and `mock from './mockdata'`.

Since we don't need all the data from the mock for this table, we haven't created any functions to handle nested arrays yet - we will ommit the product variants, for the convenience of this workshop.

We can do this in the scope of our component, but this means we need a return statement to handle our jsx.

```
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import mock from './mockdata';
import Table from './components/Table';

const App = ({ className }) => {
  const { Variants, ...rest } = mock[0];
  const keys = Object.keys(rest);
  const rows = mock.map(row => {
    const { Variants, ...rest } = row;
    return Object.values(rest);
  });
  const headings = keys.map(key => <h2>{key}</h2>);
  return (
    <div className={className}>
      <Table headings={headings} rows={rows}>
    </div>
  );
};

App.propTypes = {
  className: PropTypes.string.isRequired,
};

export default styled(App)`
  display: flex;
  flex-direction: column;
  justify-content: center;
  text-align: center;
`;
```

Now we can run `npm run build` and `npm start` to build our app and run it on localhost, and see that our magnificent table is displaying our data.

### But ... this is just static, what about functionality?

Hang on ... we're just getting there.  Lets introduce React Hooks, and Context API.
These are all a part of the React API, so we can just expand our import without adding any more dependencies.

`import React, { createContext, useContext, useReducer } from 'react'`

Now lets start by creating a Context object and setting our mockdata as the initial state.
(We should also export this context for later purposes)

We add this code just below the imports in `App.js`, and assign it to `initialState` inside the component.
```
...
// imports above here

export const AppContext = createContext({
  productData: mock,
});

const App = ({ className }) => {
  const initialState = useContext(AppContext);
...
```

This also means we should change all our references to `mock` inside the component to now reference `productData`.

We will also wrap our returned component in a `Context.Provider`-component.

```
return (
  <AppContext.Provider value={{}}>
    <div className={className}>
      <Table headings={headings} rows={rows}>
    </div>
  </AppContext.Provider>
);
```

The Provider will pass down any props or functions placed within the object in the `value`-attribute to any child components in the DOM-tree that uses `useContext(AppContext)` - this is why we had to export AppContext so we can import it, and pass it as an argument to `useContext()` wherever we need to access its values.

Essentially this provides us with a similar global state management to redux, without adding the extra dependency.

### But why did we import useReducer then?

Aha - but we haven't actually intialised a global state yet, and thats why we have no data to pass down through our provider.

So lets write a reducer, to use with useReducer.  This will be the function we call every time we wish to make changes to the state.

Make a new file `{root}/reducers/AppReducer.js`.
Also copy this code in to a file `{root}/util/sort.util.js` - we will use it later.
```
export const sortByName = (a, b) => {
  a = a.toLowerCase();
  b = b.toLowerCase();
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
};
```

Now import our `mock` and `sortByName` into `AppReducer`. Take notice that `sortByName` is a named export, whereas `mock` is a default export.  All named exports must be wrapped in curly braces, whereas default exports should not.

Our `appReducer`-function should take two arguments, the current `state` and the `action` to be performed - also, since the state in this workshop only contains `productData` we can save ourselves some time and immediately deconstruct it.

`let { productData } = state;`

The most common way to write a reducer is to write a switch statement, that will switch based on the type of constant recieved through the `action` object.

```
switch (action.type) {
  case 'FILTER': {
    return { ...state, newState };
  }
  case 'SORT': {
    return { ...state, newState };
  }
  case 'DELETE': {
    return { ...state, newState };
  }
  default:
  return state;
}

export default appReducer;
```

Now lets write some simple algorithms to decide how to deal with each type of action.

```
import mock from '../mockdata';
import { sortByName } from '../util/sort.util';

const appReducer = (state, action) => {
  let { productData } = state;
  switch (action.type) {
    case 'FILTER': {
      productData = [ ...productData, ...mock ];
      productData = productData.filter(product => product[action.target].toLowerCase().includes(action.filter));
      return { ...state, productData };
    }
    case 'SORT': {
      productData = productData.sort((a, b) => sortByName(a[action.target], b[action.target]));
      return { ...state, productData };
    }
    case 'DELETE': {
      productData = productData.filter(product => product['ArticleID'] !== action.target);
      return { ...state, productData };
    }
    default:
      return state;
  }
}

export default appReducer;
```

Reducers can handle much more complex logic, and a much wider array of action types then this - but this is all we need for this workshop.  Also note that our newState that we merge into the state object is our updated array of productData.  Again, this is just done for the convenience of the workshop, but normally this logic would be more abstract to be able to handle more cases.

### ...okay... so we have a reducer?

Now lets use it - head back to our `App.js`.

Beneath our initialisation of the Context, add the following code

```
const initialState = useContext(AppContext);
const [{ productData }, dispatch] = useReducer(
  appReducer,
  initialState,
);
const { Variants, ...rest } = productData[0];
```
What we see here is actually `{ productData }` being initialised as the `state` object in our reducer, and `dispatch` as a function to create new actions.

Now if you remember we used more arguments then `action.type` in our reducer, when using the `'SORT'`-constant we used `action.target`.

Lets try to invoke this action on a target - our table headings should be the perfect place.
`const headings = keys.map(key => <h2 onClick={() => dispatch({ type: 'SORT', target: key })}>{key}</h2>);`

And perhaps we could use a filter to sort through our `SupplierName` values?  Then we need to add a text-input so we can type out what we want to filter by.
```
<input placeholder="Seach here" type="text" onChange={e => dispatch({ type: 'FILTER', filter: e.target.value, target: 'SupplierName' })}/>
        <Table headings={headings} rows={rows}/>
```
But we can even pass down our dispatch function and state through the `Context.Provider`.

`<AppContext.Provider value={{ productData, dispatch }}>`

And then if you remember, we can retrieve and use that dispatch function in any child component we want, such as our `Row`.

```
import React, { useContext } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { AppContext } from '../App';

const Row = ({ className, values }) => {
  /* Deconstructing our dispatch function from the Context provided in App.js */
  const { dispatch } = useContext(AppContext);
  return (
    <tr className={className}>
      {values.map((value, index) => <td key={index}>{value}</td>)}
      <td>
        <button onClick={() => dispatch({ type: 'DELETE', target: values[0] })}>Delete</button>
      </td>
    </tr>
  );
};

Row.propTypes = {
  className: PropTypes.string.isRequired,
  values: PropTypes.array.isRequired,
};

export default styled(Row)`
  width: 100%;
`;
```

Now if we try to run `npm run build` and `npm start` - we should find that clicking on a heading will sort our table by that column, typing in a filter will immediately filter the table - and clicking on our tiny new delete button, removes the item.

Now all that's left to do is to add some style, and thats where the styled-components in.

We have added this method `styled` to every export with some tagged template literals following.

In here we can write normal css that will remain local in the component, and by order of specificity will gain presedence.  This is more of a playground then anything, you can find the style I used in my example code or make your own - with one neat exception to regular `scss` - you have access to any prop passed into the component from the parent simply by using e.g. `color: ${props => props.someprop ? 'green' : 'red'};`.

Now play around and see what you can do with what you learned, and feel free to ask questions!